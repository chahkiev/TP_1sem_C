//Чахкиев Магомед АПО-11
/*Задача A-3. Задача о максимальном подотрезке.
Time limit:	14 s
Memory limit:	64 M
Составить программу определения такого максимального подотрезка среди элементов заданного целочисленного массива, элементы которого увеличиваются по порядку на 1. 
Подотрезок массива - это часть ("кусок") массива, который включает в себя все элементы исходного массива от некоторого начального индекса до некоторого другого конечного индекса без изменения порядка следования элементов. Элементы подотрезка функция должна вернуть через указатель-параметр, а ее длину — через возвращаемый результат. 

Формат входных данных: 
N - длина входного массива 
A1 ... An - целочисленный массив 

Формат выходных данных: 
N - длинна найденного подотрезка 
A1 ... An - подотрезок 

Гарантируется, что все значения помещаются в 32-битный целый тип (int). Если заданный подотрезок не найден, или если найден только вырожденный подотрезок (длиной 1), необходимо вывести только длину - 0. Если подходящих подотрезков несколько, то необходимо вывести информацию (длину, подотрезок) про первый из них. 

Программа должна уметь обрабатывать ошибки во входных данных (отрицательное количество элементов и др.). В случае возникновения ошибки нужно вывести в поток стандартного вывода сообщение "[error]" (без кавычек) и завершить выполнение программы. 

ВАЖНО! Программа в любом случае должна возвращать 0. Не пишите return -1, exit(1) и т.п. Даже если обнаружилась какая-то ошибка, все равно необходимо вернуть 0! (и напечатать [error] в stdout).
*/


#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int init(int n, int *a, int *mas){
    char a0[3];
    for (int i = 0; i < n; i++) {       //инициализация массива
        scanf("%s", a0);

        if (strcmp(a0, "0")!=0  && atoi(a0)==0) {
            printf("[error]");
            free(a);
            free(mas);
            return 1;
        }
        else {
            a[i]=atoi(a0);
        }
        mas[i] = 0;      //инициализация нулями доп массива
    }
    return 0;
}

int logic(int n, int *max_len, int *index, int *a, int *mas) {
    int d = 1;
    for (int i = 0; i < n - 1; i++) {
        if (a[i] + 1 == a[i + 1]) {
            d++;
        } else {
            if (d > *max_len && mas[d] == 0) {
                mas[d] = i;
                *max_len = d;
            }
            d = 1;
        }
    }

    if ( d>1 && d>*max_len && a[n-2]+1==a[n-1] ){
        if (d >*max_len && mas[d]==0) {
            mas[d] = n-1;
            *max_len = d;
        }
    }

    for (int i=0; i<n-1; i++ ){
        if (mas[i]>mas[0]) mas[0]=mas[i];
    }

    if (mas[0]!=0) *index=mas[0];
    else *max_len = 1;
    return 0;
}

int output(int max_len, int index, int *a){
    if (max_len == 1) {         //если последовательностей в массиве не найдено
        printf("0");
    }
    else {
        printf("%d",max_len);  //длинна наибольшей последовательности
        printf("\n");

        for (int i=index-max_len+1; i<index+1 ; i++){
            printf("%d",a[i]);
            printf(" ");
        }
    }
    return 0;
}


int main() {
    int *a;  // указатель на массив
    int *mas;
    int n = 0, max_len = 0, index = 0;

    scanf("%d", &n);
    if (n <= 0) {
        printf("[error]");
        return 0;
    }

    a = malloc((n) * sizeof(int));    //выделение памяти под массив
    mas = malloc((n) * sizeof(int));    //выделение памяти под массив
    if (a == NULL) {
        printf("[error]");
    }

    if (init (n, a, mas)!=0) return 0;  //инициализация массива
    logic(n, &max_len, &index, a, mas);
    output(max_len, index, a);

    free(a);
    free(mas);
    return 0;
}